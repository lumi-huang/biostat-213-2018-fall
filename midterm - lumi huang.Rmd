---
title: "midterm"
author: "Lumi Huang"
date: "11/3/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Assume that your restaurant opens at 8am and closes at 5pm. Customers arrive at a rate of 4/hr. Between the hours of noon and 1 that rate increases to 6/hr. Suppose you have 3 tellers. We have studied 3 types of queuing systems**
**(1) 1 line with parallel servers**
**(2) tandem service (In-N-out example)**
**(3) where each teller has their own line.**
**Given three tellers which queuing system has the shortest expected waiting time for the customer?**

time variable: amount of simulated time t
counter variable: number of time a certain event occurs at time t
system state: describe system at time t
(1) 1 line with parallel servers
```{r}

```

(2) tandem service (In-N-out example)
```{r}
N <- 100 #number of customer
cust.wait <- numeric(N)
Tp <- numeric(N)
depart <-numeric(N)

Timepast <- numeric(N)
i <- 0

for (i in 1:N) {
  #starting the loop and initializing
  t <- 0 #time starts at 0
  T1 <- 8
  A1 <- 0 #arrival time of customer at server 1
  A2 <- 0 #arrival time of customer at server 2
  A3 <- 0 #arrival time of customer at server 3
  D <- 0 #departure time of customer
  lambda1 <- 4 #lambda rate between 8am-12pm and 1pm-5pm
  Na <- 0 #number of arrival by time t
  Nd <- 0 #number of departure by time t
  u1 <- runif(1)
  #t <- t -1/lambda*log(u1)
  n1 <- 0 #number of customers in line at server 1
  n2 <- 0 #number of customers in line at server 2
  n3 <- 0 #number of customers in line at server 3
  t1 <- 9999 #service completion time of customer being serve at server 1
  t2 <- 9999 #service completion time of customer being serve at server 2
  t3 <- 9999 #service completion time of customer being serve at server 3
  
  #between 8am to 12pm
  while(t < T1){
    case <- 0
    #generate T0 and set Ta = T0
    while (case == 0){
      u2 <-runif(1)
      lt <- 1/ ((t -4)^2 + .5)
      lambda.t <- lt/lambda1
      if(u2 <= lambda.t)
      { u1 <- runif(1)
      T0 <- t  - 1/lambda1*log(u1)
      Ta <- T0
      case<- case + 1
      }
    }
    
    #case 1: someone arrives at server 1
    if(Ta == min(Ta, t1, t2, t3) & Ta < T1){
      t <- Ta
      Na <- Na + 1
      n1 <- n1 + 1
      A1[Na] <- t
      
      #generate Tt and reset Ta = Tt
      case <- 0
      while (case == 0){
        u2 <- runif(1)
        lt <- 1/ ((t - 4)^2 + .5)
        if (u2 <=  (lt/ lambda1)){
          u1 <- runif(1)
          Tt <-  t  - (1/lambda1)*log(u1)   #generate time of next arrival
          Ta <- Tt			 #update time	
          case<- case + 1
        }
      }
      
      if (n1 == 1){
        Y1 <- rgamma(1,1,4)
        t1 <- t + Y1		#t1=t+Y because system was empty and t1=infty
      }
    }
    
    #case 2: someone leaves server 1 before someone arrives at server 1 
    #and before someone arrive at server 3
    if(t1 < Ta & t1 <= t2 & t1 < t3){
      t <- t1
      n1 <- n1 - 1
      n2 <- n2 + 1
      A2[Na - n1] <- t
      if(n1 == 0){
        t1 <- 9999
      }
      else{
        Y1 <- rgamma(1, 1, 4)
        t1 <- t + Y1
      }
      
      if(n2 == 1){
        Y2 <- rgamma(1, 1, 4)
        t2 <- t + Y2
      }
      
    }
    
    #case 3: someone leaves server 2 before someone arrives at server 2 
    #and before someone arrives at server 1
    if(t2 <= t3 & t1 > t2 & t2 < Ta){
      t <- t2
      n2 <- n2 - 1
      n3 <- n3 + 1
      A3[Na - n2] <- t
      if(n2 == 0){
        t2 <- 9999
      }
      else{
        Y2 <- rgamma(1, 1, 4)
        t2 <- t + Y2
      }
      
      if(n3 == 1){
        Y3 <- rgamma(1, 1, 4)
        t3 <- t + Y3
      }
    }
    
    #case 4: someone leaves server 3 before someone arrive at server 3 
    #and before someone arrives at server 2 and before someone arrives at server 1
    if(t3 < t2 & t3 < t1 & t3 < Ta){
      t <- t3
      Nd <- Nd + 1
      n3 <- n3 -1
      D[Nd] <- t
      if(n3 == 0){
        t3 <- 9999
      }
      if(n3 > 0){
        Y3 <- rgamma(1, 1, 4)
        t3 <- t + Y3
      }
    }
    
    
  }
  #case 5: store closed but someone in store
  if(min(Ta, t1) > T1 & (n1 > 0 | n2 > 0 | n3 > 0)){
    while(n1 > 0){
      t <- t1
      n1 <- n1 - 1
      n2 <- n2 + 1
      A2[Na - n1] <- t1
      if(n1 > 0){
        Y1 <- rgamma(1, 1, 4)
        t1 <- t + Y1
      }
    }
    while(n2 > 0){
      t <- t2
      n2 <- n2 - 1
      n3 <- n3 + 1
      A3[Na - n2] <- t2
      if(n2 > 0){
        Y2 <- rgamma(1, 1, 4)
        t2 <- t + Y2
      }
    }
    while(n3 > 0){
      t <- t3
      n3 <- n3 - 1
      Nd <- Nd + 1
      D[Nd] <- t3
      if(n3 > 0){
        Y3 <- rgamma(1, 1, 4)
        t3 <- t + Y3
      }
    }
  }
  
  
  #case 8: store closed and no one in the store
  if (min(Ta, t3) > T1 & n3 == 0){
    Tp <- max(t - T1, 0)
    Timepast[i] <-Tp
  }

  cust.wait[i] <- sum(D-A1)/Na
  depart[i] <- t
  i <- i+1
}



    
    

```

(3) each teller has their own line (grocery store)
```{r}
```